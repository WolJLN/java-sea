### redis实现的分布式锁

实现原理是set方法，因为多个线程同时请求的时候，
只有一个线程可以成功并返回结果，还可以设置有效期，来避免死锁的发生，
一切都是这么的完美，不过有个问题，在set的时候，会直接返回结果，成功或者失败，
不具有阻塞效果，需要我们自己对失败的线程进程处理，有两种方式:
* 丢弃
* 等待重试 由于我们的系统需要这些数据，那么只能重新尝试获取。
这里使用redis的List类型实现等待序列的作用

背景：
最近在做一个消费Kafka消息的时候发现，由于线上的消费者过多，经常会遇到，多个机器同时处理一个主键类型的数据的情况发生，如果最后是执行更新操作的话，也就是一个更新顺序的问题，但是如果恰好都需要插入数据的时候，会出现主键重复的问题。这是生产上不被允许的(因为公司有异常监管的机制，扣分啥的)，这是就需要个分布式锁了，斟酌后用了Redis的实现方式(因为网上例子多)

参考自：https://juejin.im/post/5d077d04f265da1b5f265661

TODO: 还需要测试
